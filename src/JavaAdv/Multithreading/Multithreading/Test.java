package JavaAdv.Multithreading.Multithreading;

/**
 * Многопоточность.
 * Мы запускали программу до этого и все команды запускались последовательно.
 * Мы запускали main поток (главный). Остальные будут отпочковываться от главного.
 * Все что в main - работают в одном потоке, последовательно.
 *
 * Многопоточность позволяет выполнять код параллельно с другим кодом.
 * Может работать независимо от ядер ПК.
 * Многопоточность представлена в виде виртуальной параллельности.
 *
 * Если одно ядро, то процессор переключается между участками кода очень быстро.
 * Быстро ходит между потоками и быстро выполняет код разных потоков.
 * Это и есть виртуальная парралельность (видимость выполнения кусков кода одновременно).
 *
 * Если много ядер - распределение на разные ядра процессора (равномерно между всеми ядрами процессора).
 * Важно понимать, что это не основная цель - ускорить работу программы.
 * Основная цель - чтобы клиент не ждал (т.е что-то в фоновом режиме и тд).
 */
public class Test {
    public static void main(String[] args) throws InterruptedException {
        MyThread myThread = new MyThread();
        myThread.start(); // Вызываем start(), тем самым создаем поток, вызываем метод run() и код в нем
        // Метод run() вызывать не нужно, он именно для внутреннего использования
        MyThread myThread2 = new MyThread();
        myThread2.start(); // Запуск 2го потока, создали, запустили.

        System.out.println("Im going to sleep");
        Thread.sleep(3000); // Прерывает свою работу и ждет 3 секунд
        System.out.println("Im awake");
        /**
         * Метод main запускает поток и выполняет код далее
         *
         * То есть соверешенно не гарантируется, что поток MyThread выполнится раньше кода в потоке main
         * Потоки борются за выполнение. Разная выдача потоков.
         *
         * sleep() - статический метод, вызывает засыпание на какое-то количество миллисекунд
         * Его можно использовать в любом потоке.
         */

        Thread thread = new Thread(new Runner());
        thread.start();

        /**
         * Поток main после выполнения всех инструкций (в данном случае запуска потоков)
         * Завершает свое выполнение. Но т.к мы породили новые потоки - пока они не завершатся
         * программа не завершится
         */
    }
}

/**
 * 1й способ создания потока:
 */
class MyThread extends Thread{ // Создаем класс и наследуемся от класса Thread, вызовем в main и это будет отдельный поток
    public void run(){ // именно в методе run(), который мы переопредляем указываем код, который необходимо выполнять
        for (int i = 0; i < 1000; i++){
            try {
                Thread.sleep(1000); // На каждой итерации делаем паузу 1с
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("Hello MyThread" + i); // будем конкатинировать еще и счетчик, чтобы увидеть как 2 потока работают
            // если бы они были синхронизованы было бы 0 0 1 1 2 2 и тд, но они не синхронизированы
            // Потоки получают процессорное время в случайном порядке.
        }
    }
}

/**
 * 2й способ создания потока:
 */
class Runner implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("Hello MyThread" + i);
        }
    }
}
