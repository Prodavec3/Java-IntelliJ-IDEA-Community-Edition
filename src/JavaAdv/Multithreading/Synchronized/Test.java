package JavaAdv.Multithreading.Synchronized;

/**
 * Изучение синхронизации потоков в случае, когда 2 или более потоков пишут в одну и ту же переменную
 * Тут volatile не будет работать, а необходимо использовать synchronized
 */
public class Test {
    private int counter;

    public static void main(String[] args) throws InterruptedException {
        Test test = new Test(); // каждому объекту присваивается сущность "Монитор"
        // эта сущность в 1 момент времени может быть только у 1 потока
        // только 1 поток может завладеть монитором одного объекта
        // Монитор нужен чтобы поток мог получить доступ к полям или методам объекта

        // Если не указываем на каком объекте синхронизируемся, то это происходит по this

        // В данном случае this это test
        test.doWork();
    }

    public synchronized void increment(){ // Метод использует: Только 1 поток только в 1 момент времени, 1 исполняет все остальные ждут
        counter++;
    }

    public void doWork() throws InterruptedException {
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10000; i++){
                    increment();
                }
            }
        });

        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10000; i++){
                    increment();
                }
            }
        });

        thread1.start();
        thread2.start();
        /**
         * Запустили потоки, но не дождались выполнение и сразу вывели на экран
         */
        System.out.println(counter);
        /**
         * Чтобы подождать выполнение потоков надо использовать join
         *
         * Когда мы идем в главном потоке main - запускаем метод doWork, поток main доходит до вызовов
         * 2х потоков и если нет join - то main мгновенно выведет значение на экран.
         * А мы хотим подождать выполнение потоков.
         */
        thread1.join();
        thread2.join();

        System.out.println(counter); // результат нестабильный, потому что происходит состояние гонки
        /**
         * Оба потока пишут одновременно в переменную и часть инструкций теряется.
         * Операция инкремента не атомарна (считать старое значение, суммировать и записать).
         * 2 потока бываются инкементировать - берут старые значения и перезаписывают друг друга
         * 1: 100 -> 101 первый поток записал 101, а потом включается 2й, а там в памяти значение 100
         * 2: 100 -> 101
         * А может 1й поток записал много значений, а поток 2 запомнил старое и включился позже и вернул обратно
         * старое значение
         *
         * Исправить состояние гонки (Race Condition) может synchronized
         * synchronized может использовать только метод.
         */


    }
}
