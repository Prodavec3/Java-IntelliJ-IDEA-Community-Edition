package JavaAdv.Multithreading.Volatile;

import java.util.Scanner;

/**
 * Если нам необходимо чтобы программа работала одинаково при каждом запуске (исключить хаотичность вывода потоков)
 *
 * ОС может выбрать поток, сделать его более приоритетным - проработает больше
 * Сам поток может захватить инициативу и ее не отдавать (помимо программы процессор еще что-то делает).
 * Так же от количества свободных ядер и тд.
 *
 * Т.е определить какой будет вывод - нельзя.
 *
 * Существует синхронизация потоков.
 * volatile - если 1 переменная делится между потоками. 1 поток в нее пишет другие потоки читают.
 */
public class Test {
    public static void main(String[] args) {
        MyThead myThead = new MyThead();
        myThead.start();

        // Допустим, мы хотим из потока main отключить вывод в потоке myThread
        Scanner scanner = new Scanner(System.in);
        scanner.nextLine(); // поток main ждет пока мы что-либо не нажмем или не напечатаем

        myThead.shutDown();  // Теоретически это может не работать, если комбинация каких-то факторов случилась
        /**
         * Чтобы код работал всегда необходимо использовать volatile. Когерентность кэша.
         * Ядро процессора напрямую общается с кэшем и туда попадают только важные для процессора данные, нужные сейчас для выполнения процесса.
         * Создалось 2 потока и вполне возможно что 2 потока на 2 ядра распределилось и каждом ядре выполняется свой поток
         * main на 1 и myThread на 2м например. Может случиться, что поток закэширует переменную к себе в кэш
         * и переменная всегда будет true
         * даже когда main изменит ее в дальнешейшем - переменная в ядре закеширована и ядро будет считать переменную всегда true
         * Это и есть проблема когерентности кэша.
         *
         * Когерентность это совпадение.
         * В большинстве новых процессоров все работает хорошо. Т.к кэши выгружаются в общую память и там сравниваются.
         * Но не всегда.
         *
         * volatile помечаем переменную - переменная может быть изменена и надо ее кэшировать
         * Гарантирует когерентность кэшей.
         * Переменная не будет кэшироваться в кэше каждого ядра.
         * Каждый поток будет обращаться к главной памяти и будет брать ктуальное значение переменной
         */
    }
}

class MyThead extends Thread{ // Наследуемся от класса
    private volatile boolean isRunnging = true;

    @Override
    public void run() {
        while (isRunnging){
            System.out.println("Hello, time: " + System.currentTimeMillis());
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }

    public void shutDown(){
        this.isRunnging = false;
    }
}
/**
 * То есть когда один поток записывает в переменную, а другой читает - юзаем volatile
 * для обеспечения когерентности
 */
